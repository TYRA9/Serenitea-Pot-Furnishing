先简单介绍，逐一演示[十大功能]
再详细介绍（注意文档最后的PS）

1.用户注册（JQuery校验用户的各条信息, Web-Service-DAO三层结构）
	[为防止恶意注册，使用验证码机制,此时需要导入两个jar包，kaptcha和filter(解决Tomcat10的兼容问题！)
	前端使用JQuery对验证码进行校验；后台使用kaptcha对用户输入的验证码进行校验]
	[前端需要给出用户注册失败的错误信息，提示用户更改；并且要将用户名和注册邮箱回显到注册页面。若注册时验证码错误，则还要提示用户返回到注册页面]
	[利用JQuery操作Ajax，验证用户名是否可用]

2.用户登录（同上,利用EL表达式进行回显)——
	并且，普通用户登录后，首页要根据用户登录的状态来显示不同的首页功能
	[利用session域来实现]。
	[关于验证码——为防止恶意破解密码，刷票，灌水等；验证码的校验同用户注册一样]
	[介绍普通用户的DAO-Service-Web三层结构的各自具体实现]
	[前端需要给出用户登录失败的错误信息，并将用户名回显给到浏览器页面]

3.管理员后台登录
	(管理员区别于普通用户，会建立单独的pot_manager表，并且要单独实现自己的DAO-Service-Web三层结构)
	(为使普通用户和管理员不冲突地使用各自的功能[管理员和普通用户共用order页面]，potManagerServlet中既要将potManager对象放入session域中，也要利用request域 + 请求转发，将mgrId放入request域中，实现精准打击)
	(管理员区别于用户，管理员登录的页面仅管理员知道，不对外公开，用户在首页看不到管理员的登录页面)
	[管理员也可以作为用户登录。但是，若在管理员登录界面登入，将直接进入摆设后台管理页面，也就是说，管理员在执行管理操作时，并不参与普通用户的功能]
	[后台管理页面需要对管理员的登录状态进行校验，若检测到管理员是合法登录的，就可以正常使用后台管理的相关功能，若检测到管理员没有合法登录，即未处于正常的登录状态，就不可以使用后台管理的功能，点击会自动跳转到管理员登录页面]
	[管理员登录后，仅在Furnishing Admin 和 Order Admin两个主页面展示管理员的name]

4.*摆设*管理(管理员可以进入摆设管理页面，进行摆设的修改和删除操作)
		（摆设管理页面要进行分页展示！）
		（分页显示涉及到数据模型Page的定义，以及Service层一个方法对DAO层多个方法的调用；并且要根据业务需求，确定在摆设增加，删除或者添加新的摆设后，摆设后台管理要停留在哪个页面）
	4.1修改摆设——
	超链接挂到新的页面(新的页面的表单中要实现数据的回显[WEB层的listSpecificOne],方便管理员修改)，
	进行修改操作时，前端使用JQuery进行数据校验，后端采用Apache BeanUtils进行封装，注意修改摆设时，需要一并将当前摆设对应的id传递给furnishingServlet.修改成功后请求重定向到摆设管理页面。

	4.2删除摆设——
	直接为摆设管理当前页面的删除按钮设置超链接，提交当前摆设的id，后台根据id删除对应的摆设，删除时通过confirm方法弹出确认窗口，删除后请求重定向到摆设管理页面。

	4.3添加新的摆设——
	超链接挂到单独的jsp页面。数据校验—前端JQuery校验，后端采用BeanUtils封装，添加成功后请求重定向到摆设管理页面。

5.首页展示摆设——
	5.1 首页分页展示，与后台分页展示类似(使用Page数据模型来控制)
	5.2 对超链接做JQuery校验，防止页码越界
	5.3 注意对index.jsp(真正的首页)做了入口封装的处理。
	5.4 首页不会显示库存<=0的摆设(修改俩个sql语句的条件[getRecordSumByName和getPageItemsByName]，即管理员可以在后台看到库存为0的摆设；而用户在前台看不到库存为0的商品)。

6.首页搜索——
	6.1 DAO-->Service中定义新的方法(实际就是在首页分页展示的基础上增加了name校验)
	6.2 presentToUsersServlet中定义新的分页方法pagingByName，通过name值来进行分页(DAO-Service-Web一体)
	6.3 令入口页面index.jsp通过JSP转发标签转发到新的分页方法，保证首页的分页效果。
	6.4 在搜索表单中嵌入多个hidden的input标签。
	6.5 根据搜索情况的不同，做出不同的业务处理，注意对于0搜索结果——即pageAmount等于0时前后端各做了哪些校验。(fore-JQuery, end-if)
	6.6 利用EL内置对象requestScope展示从数据库中获取的新的摆设，搜索后的结果依然支持分页超链接的展示。
	
7.用户退出——
	7.1 Web层对应的servlet中增加新的方法，该方法将session中的该用户销毁。同时跳转到首页。(为Log Out绑定事件,利用confirm方法弹出一个对话框，用于确认用户是否退出)

8.购物车管理 ——（展示，添加，修改，删除，清空）
	8.0 关于购物车表shopping_cart表的设计(id, fid, uid的使用) --> domain -->...
	8.1 首页面添加摆设到购物车(若检测到用户未登录，则跳转到用户登录页面)
		[该情景下，所用DAO层方法中的sql语句采用了固定式的写法]
		[要利用之前用过的分页方法，让用户停留在添加商品时所在的页面]
	8.2 购物车页面显示(需要回显数据库中最新的购物车信息，首页每次点击购物车时进行更新)
	8.3 修改购物车（新定义一个updateCntAndTotalPrice方法，利用了"取出-修改-放入-再取出"的思想，解决了数据回显不一致的问题。)
	8.4 删除购物车中的指定条目(DAO-->Service-->Web经典三层结构，前端使用Jquery确认用户的删除操作)
	8.5 清空购物车(同删除购物车的实现类似，不难)

9.订单管理
	9.1 生成订单
	(订单管理功能需要建两张表，分别是order和order_item[订单表用于保存不同用户的不同订单，需要保存订单总的金额;而订单项表则用于保存所有订单中详细的订单项信息，包括每件购买的商品的单价数量总价等，并且每个订单表项记录要关联该商品对应的订单]。
	[对应的domain层要定义两个对应的JavaBean类]
	service层具体实现———一个Service调用多个DAO；且只定义一个Service而对应定义了多个DAO，多个DAO为一个Service服务)
	用户在结账时会生成对应的订单，注意，结账时会进行前后端的校验，防止空订单。
	9.2 显示订单
	用户可以在自己的首页，或者是结账后的页面，去查看自己的所有订单。而管理员则是查看所有用户的所有订单，因此前端要对当前用户的身份进行校验，判断是管理员还是普通用户。
	[管理员和普通用户共用order.jsp及order_item.jsp页面]
	9.3 订单详情
	点击订单的details，可以查看当前订单的详细信息，包括订单包含的具体商品以及各自的数量和价格。
	用户只能看自己订单的详细信息；管理员可以看到所有。
	[管理员和普通用户共用order.jsp及order_item.jsp页面]

10.上传更新摆设图片
	10.1 在furn_update页面增加关于上传文件的css/js代码。
	10.2 修改furn_update页面中的提交表单(新增enctype属性;将img标签使用div包起来，在该div中增加一个之前用过的type=file的input标签)
	     (去除hidden标签，直接追加到url后)
	10.3 更新FurnishingServlet中的update方法(因为前端表单中修改了enctype属性为multipart/form-data，因此不能再使用BeanUtils进行数据的封装)
		[update方法中就是正常"上传文件"的代码]
	10.4 同之前“修改摆设”一样，修改后要跳转到修改前所在的页面(包括分页页码也要一致)
	10.5 若发现管理员在修改摆设时没有上传新的图片，就不对摆设图片作处理。




------------------------------------------------------------------------------------
PS:(1)过滤器对非法访问进行校验。
	1>在web.xml配置文件中配置两个过滤器(PotManagerFilter和PotUserFilter，分别用来拦截对后台管理页面和用户前台页面的非法访问。注意，对于两个登录页面要给予放行)

PS:(2)事务管理(确保数据库中表的数据的一致性)
	1>升级JDBCUtilsDruid工具类，从ThreadLocal中获取绑定的连接，包装DAO层操作数据库时，每次获取到的连接都是同一个连接。
		[新定义getConnection()方法；单独定义commit()方法和rollback()方法]
		[JDBCUtilsDruid的commit和rollback方法中已经关闭的连接，所以可以撤掉BasicDAO中关闭连接的部分]
	2>为了对所有对数据库的操作都进行事务控制，采用Filter过滤器来实现！
